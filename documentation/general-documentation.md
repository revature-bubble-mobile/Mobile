# Bubbl(e) Mobile Documentation

## Overview

---

Bubbl(e) Mobile is a mobile version of the [Bubbl(e) Web-App](http://ec2-44-197-172-46.compute-1.amazonaws.com:3000/login). This mobile version was created to be a one-to-one visual and functional representation of the web version. The mobile and web versions were created by two different teams. For the front end, the majority of features that could be replicated were included. Some features could not be replicated one for one because of several issues found with the backend originally created for the web version. These changes are documented within the web-app changes section.

### Expo and Node Modules

Bubbl(e) Mobile was created using Expo with TypeScript. Expo was used because it creates a dev server and pulls together several community node modules that are commonly used together. Expo can normally be used to emulate the application on the Web (within a browser), Android, and IOS. However, the Web emulation will not currently work (due to a dependency) and this application will only run on either a physical mobile device or a mobile emulator.

Additionally, React Native (for mobile development) is behind in the release version from the current React (for web development). Expo is also behind the React Native current release version. Because of this, some features and common node modules that are commonly used may cause issues. One such example is Enzyme for testing.

Enzyme is a testing framework built off of the Jest framework. To get Enzyme to work, another module _'Enzyme for React'_ needed to be included, and a patch also runs.

The following is a list of node modules that were added that are _not included_ in Expo. **Running npm i** or yarn install will initialize the project:

1. \*\*react-native-reanimated
2. react-native-gesture-handler
3. react-native-elements
4. react-native-safe-area-context
5. react-native-screens
6. enzyme
7. redux
8. react-redux

\*\*The package _'react-native-reanimated'_ does not work on web. If a static browser webpage is desired, this package will need to be uninstalled and any component dependencies will need to be re-worked.

## Differences Between The Mobile And Web Version

---

**Warnings For Future Teams:**
Firebase and Azure Functions will not be provided long term because of cost. Any future utilization of the front end will need to have a new backend created for communication.The easiest way to have no changes made to the frontend and have it stay compatible with a different backend would be the following:

1. All HTTP calls reference one of these endpoints within the _endpoints.ts_ file. Simple change these endpoints as desired to the endpoint of another backend.
2. To ensure consistent behavior, it would be recommended to map all endpoints to an Azure Function (or equivalent service) as _"glue code."_ From here this function can interact with the database or other API as needed to filter and manipulate the functionality of the Firebase-Azure backend.

The reason for having two different backends was to easily streamline how IDs for the firebase database are created. By default, Firebase stores all information in the database as one single JSON. From there All other data is attached to this JSON as a property with a specific key. This allowed data requests to be more surgical and lighter.

```JavaScript
//firebase JSON example

MainObject:{
    key1:{
        pid:'ExampleID1',
        property1:...,
    },
    key2:{
        pid:'ExampleID2',
        property1:...,
    },
    ...
}
```

However, one issue with firebase is that a key is generated by Firebase, and in order to get that object associated with that key, one needs to know this key and use it to make a get request to Firebase. Using this system, there is no direct way to get a single object without having to call the entire JSON and filter it. Despite being an improvement for our needs, this is still undesirable for security, efficiency, and latency.

The second issue came with the ability to log in. Firebase does have _"Firebase Authentication"_ which is a system that could be used. However, this information was discovered late in the development of the application. Because of the three-week window for development, it was decided that it would be easier not to include this as it would have taken a large time investment to learn how to incorporate the login information and user data as one return from a patch request.

### **General Changes**

The first major difference between the two versions of the application is the backend used. At the start of the project, an initial API was given ([API Document](http://ec2-44-197-172-46.compute-1.amazonaws.com:5000/swagger-ui.html#/)).

The endpoint needed for this API is: http://ec2-44-197-172-46.compute-1.amazonaws.com:5000/

When testing the API using the web version, it was discovered that several undesirable behaviors were found. One example was that when loading and creating a post, all other posts and any user profile associated with each one were copied into a post object sent to the server, and an update object was then sent back. Along with this, all images were stored as base 64 strings and also included. This created an issue where around 2Mb of information was sent each time a single get was called for a user post. This nesting of a large amount of the database within a single post was a performance issue for mobile phones that could make requests slow and cumbersome.

Therefore, the original backend was redesigned with some fixes, albeit later on in the sprint than desired. In this time, a decision was made to use Firebase and Azure for the backend. By the time the fix on the original backend was made, the decision was made to continue with Firebase and Azure instead.

**API Changes**

Not all functionality from the original backend could be replicated one-to-one for the Firebase-Azure backend. It was decided to have all DTOs match the responses from the original backend as closely as possible. Not all endpoints and behaviors could be created exactly, but the overall functionalities match.

To get this to work, two different endpoints were used. One for Firebase and one for Azure Functions:

- Azure Functions: https://wk-revature-bubble-mobile.azurewebsites.net/api
- Firebase: https://bubble-app-82a5a-default-rtdb.firebaseio.com

**Azure backend**

The Azure backend (using Azure Functions) was used to fix the issues related to Firebase. All post requests to create any new data should be sent to the Azure endpoint. The Azure function will then create a new object and associate all needed information to make get requests easier.

```JavaScript
mainObject:{
->  uuid1:{ // uuid created by Azure
->      pid:uuid1, // same uuid
        property1:...,
    },
    uuid2:{
        pid:uuid2,
        property1:...,
    },
    ...,
}
```

Creating the system mentioned above embeds the key within the pid property. The pid is used as the key needed by the frontend to make a call to the backend to reference the correct object within the main JSON.

As another example, when trying to log in, using a patch on {AzureEndPoint}/login will search Firebase for a profile that has the correct username and password, and return the object found.

### **Firebase backend**

All calls that are not a Post, or specifically a Patch to login, will use the Firebase Database directly as a backend. This is only for testing purposes and should be changed. The reason is that any person from anywhere can run full crud operations without any security. Normally for Firebase rules are supposed to be defined to restrict what users can and cannot perform on the database. For development, this has been ignored. For future iteration, if continuing with Firebase, either setting up the Firebase rules or using an intermediate server would be best to handle security and permissions.

Firebase is a NoSQL type database. All data within the database can be changed at runtime and does not need to conform to a set data model or scheme. The base URL links the main JSON. All other routes map to a specific property within the JSON similar to a tree. All data under the last route specified will be returned as one single object.

```TypeScript
const url = `${firebaseUrl}/profiles/bbb`
>/*firebaseUrl*/root:{
>    /*Profiles*/ profiles:{
                     aaa:{pid:string, username, password}
>            /*bbb*/ bbb:{pid:string, username, password, followers[],likes[]}
                     ccc:{pid:string, username, password, likes[]}
                },
                post: {
                    post1:{}
                    post2:{}
                    post3:{}
                },
                comments:{
                    ....
                }
            }
// Using the url above will return an object with the following properties:
const objectReturned = {pid:string, username, password, followers[],likes[]}.

```

\*\*Note: none of the data under profiles is consistent with all same the properties.
Ideally, the same data would be saved for all entries. However, checking on the front end may be useful to avoid unexpected errors.
Currently, to interact with all data within Firebase, no matter the type, the crud operations all work the same. _Note: All routes must have *.json* appended to the end for Firebase to work properly!_

#### **get request:**

Sending a get request to {Firebase Endpoint}/{key1}/{key2}/{key3}/.../keyN.json will return an object with all properties under that key. All data must then be filtered and manipulated from the front end.

```TypeScript
const route:string = `https://bubble-app-82a5a-default-rtdb.firebaseio.com/profiles.json`
// this will return all profiles within the database.
```

Adding an ID (specific to the ID setup by the Azure function) will retrieve the item with that key.

```TypeScript
const id:string = 'uuid here'
const url:string = `https://bubble-app-82a5a-default-rtdb.firebaseio.com/profiles/${id}.json`
// this will return an object that has the same key found on the main json object.
//The key here is the id passed and should be the same that the Azure function created.
const object:type = await axios.verb(url)
```

#### **Put and Patch request:**

All updates to the database communicate directly with the Firebase Database.

- any Put request will remove and replace all data under the route specified with the data given within the body of the request. (non-specified values will be removed). If the resource does not exist it will be created.
- any Patch will add, and or replace, only properties specified within the body of the request.
  -If the properties exist, they will be replaced.
  -if they do not exist, they will be added

Both verbs will send back the object in the database as a JSON with the updated changes.

```TypeScript
// this url is used as a post or patch
const url = `${firebaseUrl}/profiles/bbb.json`
const object:type = await httpCall(url)
{type}/*Return Json*/


```

#### **Post request:**

No post request should be made to the Firebase backend. All post requests should go to the Azure backend.

#### **Delete request:**

The front end does not currently have any deleting functionality implemented.

### **Data Models**

The following is a list of all DTOs used within the front end.

```TypeScript
interface Profile {
    /**Profile ID string, used when trying to map the route with the appropriate key on Firebase*/
    pid: string;
    firstName: string;
    lastName: string;
    /**Hashed value obtained from an existing JWT */
    passkey: string;
    email: string;
    username: string;
    imgurl?: string;
    verification?: boolean;
    followers: string[];
    following: string[];
}
interface Comment {
    /**Comment ID string, used when trying to map the route with the appropriate key on Firebase */
    cid: string;
    /**ID string of a profile that created the comment */
    writer: string;
    /**ID string of a post */
    post: string;
    /**Text entered when creating the Comment */
    message: string;
    dateCreated: Date;
    previous?: string;
}
interface Post {
    /**Unique ID of the Post, used when trying to map the route with the appropriate key on Firebase */
    psid: string;
    /**ID string of a profile that created the post */
    creator: string;
    /**Text entered when creating the Post */
    body: string;
    datePosted: Date;
    imgURL?: string;
}
```

When using the Patch with the login route to Azure, the following should be sent to the server:

```TypeScript
//Json sent
const body = {username:string,password:string}
const response = await axios.patch(url,body)
const loginProfile = response.data
```

When using the Post-> /{dataType} route with Azure, the following should be sent to the server:

When using any firebase route, it is expected that the type sent will be the same as the type requested using the corresponding id.

```TypeScript
const url:string = pid|cid|psid; // only one should be used, but any of the three are valid
// if using a put the full data model should be added as a body
1. pid  => const body = {Profile}     // if put, include body
2. cid  => const body =  {Comment}    // if put, include body
3. psid => const body = {Post}        // if put, include body

// if using a Patch, only include the data you want to update
// then make a call as needed, the following ids will map as followed
const response = axios.verb(url,body)
                // pid     | cid   | psid
const loginProfile: Profile | Comment| Post = response.data
```

Example get all profiles

```TypeScript
const url = `${firebaseUrl}/Profile`
const profileArray:Profile[]= await axois.get(url)
```

Example get single profile by ID

```TypeScript
const profile; // local profile in app from the redux store
const url = `${firebaseUrl}/Profile/${profile.pid}`
const profileArray:Profile= await axios.get(url)
```

Example put single profile by ID

```TypeScript
const profile; // local profile in app from the redux store
const body:Profile= {/*All profile properties*/}
const url = `${firebaseUrl}/Profile/${profile.pid}`
// This profile should be a complete replacement
const profileArray:Profile= await axios.put(url,body)
```

Example patch single profile by ID

```TypeScript
const profile; // local profile in app from the redux store
const followers = [/*new data*/]
const body= {followers}
const url = `${firebaseUrl}/Profile/${profile.pid}`
// This profile should be a new profile with the changes made
const profileArray:Profile= await axios.patch(url,body)
```

### **JWT**

Currently, there is no implementation for JWTs which the Web version received from the original backend. This was not included because of time constraints. However, in the profile data model, 'passkey' does exist and that would be the JWT that the original backend would send.

## Feature General Breakdown

---

Bubbl(e) Mobile includes the following features:
| Feature | Description |
| ------------ | ----------- |
| Login | A user can log in with a username and password. New users can also register a new account. |
| Profile | Users can update their profile information. |
| Profile Viewing | Users can view the profile of other users who have created a post.|
| Post Feed | Users can view a feed of all posts created from the most recent to the oldest|
| Create a post | Users can create a new post that contributes to the main feed all users will see. |
| Comments | Users can comment on posts made by previous users.|

## App Implementation (Developer Notes)

Each head under this section describes how particular features and systems interact together.

### **Session Management**

All session management is handled by using the Redux toolkit. All profile information is stored within an entity called _user_ which contains a _profile_ that is defined within the _dtos_ folder. This user profile should be available to all components from the redux store globally. It is set by the login screen when first trying to log in open the app or by the registration component when creating an account. The main reducer used is _setProfile._ The action to use can be exported directly from the _store.ts_.

### **Login, logout and registration Page**

Before the login page is displayed, within the app.ts, some logic is implemented to check if any user data is stored using AsyncStorage. If so, that data will be used and the login screen will be bypassed. If no data is presented the login screen will then be rended.

From within the login screen, several options are presented: login, registration, and forgot password. An alert will pop up if the user does not provide valid credentials. If valid credentials are found on the server, this information will be stored within AsyncStorage, the redux store will be updated and the app will render the home page first. The registration page will pop up as a model for a user to send new credentials to the server. If the user already exists within the database when trying to create a user, they will be redirected in the app. The Registration page will pop up a _“terms and condition page”_ of what needs to be accepted before proceeding. The terms and conditions are within a component that would need to be changed, currently, placeholder text has been inserted for testing purposes.

"Forget password" is not currently implemented. It is intended that the user would be redirected to another website to handle updating user credentials. This was implemented to offload authentication to a third-party system if needed. If not, then potentially creating another component with a model would need to be done.

When logging out, a button was implemented on the Draw Navigation that would clear the AsyncStorage and redirect the user to the login page.

### Draw Navigation

React Native Drawer Navigation was used for all navigation between pages after the login was successful. There are currently three main navigation options. The first one is the user profile page of the user logged in. When profile image can be clicked on to navigate the profile page directly. The profile option can also be selected to navigate to the last view profile (see profile page section). The home page option will navigate the user to the home page (see home page section). The last option will log out the user, this will clear the session storage which will cause the app.ts to render the login page directly.

### home page

The home page is an endless feed showing all comments from any user. From here a user can see the contents of any post. They can also click on a post and view the profile of the user who created it, including their own (see Post and Comments Section).

### profile page

The profile page is a component that holds many other components. This component has two different functions that can be switched between. It requires a prop of the pid of the user to display. If this pid is the same as the pid of the user login (the local user), which is stored in the redux store, then options for that user will be displayed. If it is not this user then it will display different options for a different user that is being viewed.

If the local user's profile, then a component will be displayed to update the user information. They can update their name and password as needed. These changes will be made within the redux store as well as on the backend. If it is not the local user's profile, then the option to follow this user will be displayed. This functionality is not implemented but a placeholder text will be visible.

Below this, the default feed will be displayed. In feature development, the post in the feed should be filtered to only display the post from the user being viewed. Because of time constraints and limitations with the backend, this could not be a compliment.

### Default feed, Post and Comments

The default feed is a component that holds all posts. To create a post, a user has to navigate to their profile page. Once there they can create a post. The post component is set up to allow for multiline text to be included with no limit on how long a post can be. The post component can be resized so the user can have more access to see the text as needed. Once a post has been created, any user can make a comment on a single post. the comment component can allow for comments that can only be "two-layer deep"; meaning users can only comment on a post and comment on an initial comment directly, but not continue into a thread. The comment component handles all logic for creating new comments.
