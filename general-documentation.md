# Bubbl(e) Mobile Documentation

## Overview

---

Bubbl(e) Mobile is a mobile version of the [Bubbl(e) Web-App](http://ec2-44-197-172-46.compute-1.amazonaws.com:3000/login). This mobile version was created to be a one-to-one visual and functional representation of the web version. The mobile and web versions were created by two different teams. For the front end, the majority of features that could be replicated were included. Some features could not be replicated one for one because of several issues found with the backend originally created for the web version. These changes are documented within the web-app changes section.

### Expo and Node Modules

Bubbl(e) Mobile was created using Expo with TypeScript. Expo was used because it creates a dev server and pulls together several community node modules that are commonly used together. Expo can normally be used to emulate the application on the Web (within a browser), Android, and IOS. However, the Web emulation will not currently work (due to a dependency) and this application will only run on either a physical mobile device or a mobile emulator.

Additionally, React Native (for mobile development) is behind in the release version from the current React (for web development). Expo is also behind the React Native current release version. Because of this, some features and common node modules that are commonly used may cause issues. One such example is Enzyme for testing.

Enzyme is a testing framework built off of the Jest framework. To get Enzyme to work, another module _'Enzyme for React'_ needed to be included, and a patch also runs.

The following is a list of node modules that were added that are _not included_ in Expo. **Running npm i** or yarn install will initialize the project:

1. \*\*react-native-reanimated
2. react-native-gesture-handler
3. react-native-elements
4. react-native-safe-area-context
5. react-native-screens
6. enzyme
7. redux
8. react-redux

**The package _'react-native-reanimated'_ does not work on web. If a static browser webpage is desired, this package will need to be uninstalled and any component dependencies will need to be re-worked.

## Differences Between The Mobile And Web Version
---

**Warnings For Future Teams:** 
Firebase and Azure Functions will not be provided long term because of cost. Any future utilization of the front end will need to have a new backend created for communication.The easiest way to have no changes made to the frontend and have it stay compatible with a different backend would be the following:

1. All HTTP calls reference one of these endpoints within the _endpoints.ts_ file. Simple change these endpoints as desired to the endpoint of another backend.
2. To ensure consistent behavior, it would be recommended to map all endpoints to an Azure Function (or equivalent service) as _"glue code."_ From here this function can interact with the database or other API as needed to filter and manipulate the functionality of the Firebase-Azure backend.

The reason for having two different backends was to easily streamline how IDs for the firebase database are created. By default, Firebase stores all information in the database as one single JSON. From there All other data is attached to this JSON as a property with a specific key. This allowed data requests to be more surgical and lighter.

```JavaScript
//firebase JSON example

MainObject:{
    key1:{
        pid:'ExampleID1',
        property1:...,
    },
    key2:{
        pid:'ExampleID2',
        property1:...,
    },
    ...
}
```

However, one issue with firebase is that a key is generated by Firebase, and in order to get that object associated with that key, one needs to know this key and use it to make a get request to Firebase. Using this system, there is no direct way to get a single object without having to call the entire JSON and filter it. Despite being an improvement for our needs, this is still undesirable for security, efficiency, and latency.

The second issue came with the ability to log in. Firebase does have _"Firebase Authentication"_ which is a system that could be used. However, this information was discovered late in the development of the application. Because of the three-week window for development, it was decided that it would be easier not to include this as it would have taken a large time investment to learn how to incorporate the login information and user data as one return from a patch request.

### **General Changes**

The first major difference between the two versions of the application is the backend used. At the start of the project, an initial API was given ([API Document](http://ec2-44-197-172-46.compute-1.amazonaws.com:5000/swagger-ui.html#/)).

The endpoint needed for this API is: http://ec2-44-197-172-46.compute-1.amazonaws.com:5000/

When testing the API using the web version, it was discovered that several undesirable behaviors were found. One example was that when loading and creating a post, all other posts and any user profile associated with each one were copied into a post object sent to the server, and an update object was then sent back. Along with this, all images were stored as base 64 strings and also included. This created an issue where around 2Mb of information was sent each time a single get was called for a user post. This nesting of a large amount of the database within a single post was a performance issue for mobile phones that could make requests slow and cumbersome.

Therefore, the original backend was redesigned with some fixes, albeit later on in the sprint than desired. In this time, a decision was made to use Firebase and Azure for the backend. By the time the fix on the original backend was made, the decision was made to continue with Firebase and Azure instead.

**API Changes**

Not all functionality from the original backend could be replicated one-to-one for the Firebase-Azure backend. It was decided to have all DTOs match the responses from the original backend as closely as possible. Not all endpoints and behaviors could be created exactly, but the overall functionalities match.

To get this to work, two different endpoints were used. One for Firebase and one for Azure Functions:

- Azure Functions: https://wk-revature-bubble-mobile.azurewebsites.net/api
- Firebase: https://bubble-app-82a5a-default-rtdb.firebaseio.com

**Azure backend**

The Azure backend (using Azure Functions) was used to fix the issues related to Firebase. All post requests to create any new data should be sent to the Azure endpoint. The Azure function will then create a new object and associate all needed information to make get requests easier.

```JavaScript
mainObject:{
->  uuid1:{ // uuid created by Azure
->      pid:uuid1, // same uuid
        property1:...,
    },
    uuid2:{
        pid:uuid2,
        property1:...,
    },
    ...,
}
```

Creating the system mentioned above embeds the key within the pid property. The pid is used as the key needed by the frontend to make a call to the backend to reference the correct object within the main JSON.

As another example, when trying to log in, using a patch on {AzureEndPoint}/login will search Firebase for a profile that has the correct username and password, and return the object found.

### **Firebase backend**

All calls that are not a Post, or specifically a Patch to login, will use the Firebase Database directly as a backend. This is only for testing purposes and should be changed. The reason is that any person from anywhere can run full crud operations without any security. Normally for Firebase rules are supposed to be defined to restrict what users can and cannot perform on the database. For development, this has been ignored. For future iteration, if continuing with Firebase, either setting up the Firebase rules or using an intermediate server would be best to handle security and permissions.

Firebase is a NoSQL type database. All data within the database can be changed at runtime and does not need to conform to a set data model or scheme. The base URL links the main JSON. All other routes map to a specific property within the JSON similar to a tree. All data under the last route specified will be returned as one single object.

```TypeScript
const url = `${firebaseUrl}/profiles/bbb`
>/*firebaseUrl*/root:{
>    /*Profiles*/ profiles:{
                     aaa:{pid:string, username, password}
>            /*bbb*/ bbb:{pid:string, username, password, followers[],likes[]}
                     ccc:{pid:string, username, password, likes[]}
                },
                post: {
                    post1:{}
                    post2:{}
                    post3:{}
                },
                comments:{
                    ....
                }
            }
// Using the url above will return an object with the following properties:
const objectReturned = {pid:string, username, password, followers[],likes[]}.

```

\*\*Note: none of the data under profiles is consistent with all same the properties.
Ideally, the same data would be saved for all entries. However, checking on the front end may be useful to avoid unexpected errors.
Currently, to interact with all data within Firebase, no matter the type, the crud operations all work the same. *Note: All routes must have _.json_ appended to the end for Firebase to work properly!*

#### **get request:**

Sending a get request to {Firebase Endpoint}/{key1}/{key2}/{key3}/.../keyN.json will return an object with all properties under that key. All data must then be filtered and manipulated from the front end.

```TypeScript
const route:string = `https://bubble-app-82a5a-default-rtdb.firebaseio.com/profiles.json`
// this will return all profiles within the database.
```

Adding an ID (specific to the ID setup by the Azure function) will retrieve the item with that key.

```TypeScript
const id:string = 'uuid here'
const url:string = `https://bubble-app-82a5a-default-rtdb.firebaseio.com/profiles/${id}.json`
// this will return an object that has the same key found on the main json object.
//The key here is the id passed and should be the same that the Azure function created.
const object:type = await axios.verb(url)
```

#### **Put and Patch request:**

All updates to the database communicate directly with the Firebase Database.

- any Put request will remove and replace all data under the route specified with the data given within the body of the request. (non-specified values will be removed). If the resource does not exist it will be created.
- any Patch will add, and or replace, only properties specified within the body of the request.
  -If the properties exist, they will be replaced.
  -if they do not exist, they will be added


Both verbs will send back the object in the database as a JSON with the updated changes.

```TypeScript
// this url is used as a post or patch
const url = `${firebaseUrl}/profiles/bbb.json`
const object:type = await httpCall(url)
{type}/*Return Json*/


```

#### **Post request:**

No post request should be made to the Firebase backend. All post requests should go to the Azure backend.

#### **Delete request:**

The front end does not currently have any deleting functionality implemented.

### **Data Models**

The following is a list of all DTOs used within the front end.

```TypeScript
interface Profile {
    /**Profile ID string, used when trying to map the route with the appropriate key on Firebase*/
    pid: string;
    firstName: string;
    lastName: string;
    /**Hashed value obtained from an existing JWT */
    passkey: string;
    email: string;
    username: string;
    imgurl?: string;
    verification?: boolean;
    followers: string[];
    following: string[];
}
interface Comment {
    /**Comment ID string, used when trying to map the route with the appropriate key on Firebase */
    cid: string;
    /**ID string of a profile that created the comment */
    writer: string;
    /**ID string of a post */
    post: string;
    /**Text entered when creating the Comment */
    message: string;
    dateCreated: Date;
    previous?: string;
}
interface Post {
    /**Unique ID of the Post, used when trying to map the route with the appropriate key on Firebase */
    psid: string;
    /**ID string of a profile that created the post */
    creator: string;
    /**Text entered when creating the Post */
    body: string;
    datePosted: Date;
    imgURL?: string;
}
```

When using the Patch with the login route to Azure, the following should be sent to the server:

```TypeScript
//Json sent
const body = {username:string,password:string}
const response = await axios.patch(url,body)
const loginProfile = response.data
```

When using the Post-> /{dataType} route with Azure, the following should be sent to the server:

When using any firebase route, it is expected that the type sent will be the same as the type requested using the corresponding id.

```TypeScript
const url:string = pid|cid|psid; // only one should be used, but any of the three are valid
// if using a put the full data model should be added as a body
1. pid  => const body = {Profile}     // if put, include body
2. cid  => const body =  {Comment}    // if put, include body
3. psid => const body = {Post}        // if put, include body

// if using a Patch, only include the data you want to update
// then make a call as needed, the following ids will map as followed
const response = axios.verb(url,body)
                // pid     | cid   | psid
const loginProfile: Profile | Comment| Post = response.data
```

Example get all profiles

```TypeScript
const url = `${firebaseUrl}/Profile`
const profileArray:Profile[]= await axois.get(url)
```

Example get single profile by ID

```TypeScript
const profile; // local profile in app from the redux store
const url = `${firebaseUrl}/Profile/${profile.pid}`
const profileArray:Profile= await axios.get(url)
```

Example put single profile by ID

```TypeScript
const profile; // local profile in app from the redux store
const body:Profile= {/*All profile properties*/}
const url = `${firebaseUrl}/Profile/${profile.pid}`
// This profile should be a complete replacement
const profileArray:Profile= await axios.put(url,body)
```

Example patch single profile by ID

```TypeScript
const profile; // local profile in app from the redux store
const followers = [/*new data*/]
const body= {followers}
const url = `${firebaseUrl}/Profile/${profile.pid}`
// This profile should be a new profile with the changes made
const profileArray:Profile= await axios.patch(url,body)
```

### **JWT**

Currently, there is no implementation for JWTs which the Web version received from the original backend. This was not included because of time constraints. However, in the profile data model, 'passkey' does exist and that would be the JWT that the original backend would send.

## Feature Breakdown

---

Bubbl(e) Mobile includes the following features:

- placeholder
- placeholder
- placeholder
- placeholder
- placeholder
- placeholder
- placeholder
